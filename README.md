### 0125 Valid Palindrome

#### Character 클래스
- `Character.isLetterOrDigit`: 원시자료형 char를 입력값으로 하여 영숫자인지 판별합니다.
- `Character.toLowerCase`: 원시자료형 char를 입력값으로 하여 소문자로 변경합니다.

#### String 클래스
- `charAt(int index)`: 리턴타입은 문자의 원시자료형 char입니다.

#### 사용한 자료구조 혹은 자료형
- 문자열에서 문자를 하나씩 추출하여 비교합니다.

***
### 0937 Reorder Data in Log Files

#### Character 클래스
- `Character.isDigit`: 원시자료형 char를 입력값으로 하여 숫자인지 판별합니다.

#### String 클래스
- `split`: 두 번째 인자의 숫자는 배열의 길이입니다.
- `compareTo`: 호출하는 문자열과 매개변수로 전달된 다른 문자열을 비교 후 사전순으로 정렬합니다.
- 첫 번째 문자열이 두 번째 문자열보다 앞설 경우 음수, 같을 경우 0, 뒤따를 경우 양수를 반환합니다(=즉 앞으로 와야 할 경우 양수, 뒤에 머물러야 할 경우 -1).

#### List 인터페이스
- `sort`: 정렬 기준은 Comparator 인터페이스를 구현하는 객체를 통해 지정 가능합니다.
-  (*) Comparator인터페이스의 경우 compare라는 추상메소드를 가지고 있고 해당 식에서는 람다 표현식을 통해 직접 구현함 (자바8이전은 compare 함수 @Override필요)
- `addAll`: 호출되는 리스트(letterList)의 끝에 다른 컬렉션(digitList)의 모든 요소를 추가합니다.
- `toArray`: `new String[0]`의 경우, 크기가 0인 String 배열을 생성합니다.

#### 사용한 자료구조 혹은 자료형
- 두 개의 리스트 자료구조를 이용하고, 문자로그와 숫자로그의 정렬방식이 달라 둘을 분리해 다른 리스트에 담은 후 나중에 서로 이어붙입니다.

***

### 0049 Group Anagrams

#### String 클래스
- `toCharArray`: 문자열을 char 배열로 변환합니다.
- `valueOf`: 다양한 타입의 데이터를 문자열로 변환합니다.

#### Arrays 클래스
- `sort`: int[], long[], Object[] 등 다양한 타입의 배열에 대한 sort 메소드가 존재합니다.
- Arrays 클래스의 `sort` 메소드와 List 인터페이스의 `sort` 메소드는 List 객체를 대상으로 하며 Comparator를 매개변수로 받는 차이가 있습니다.

#### Map 인터페이스
**(*)본 코드에서는 Map 인터페이스를 HashMap 클래스를 통해 구현해 아래의 추상메소드를 사용하였습니다.**
- `containsKey`: Map에 주어진 키가 있는지 확인 후 boolean 값을 반환합니다.
- `put(K key, V value)`: Map에 키-값 쌍을 추가합니다. 이미 존재하는 키에 대해 값을 넣으면 기존 값이 새 값으로 대체됩니다.
- `get(Object key)`: 주어진 키에 연결된 값을 반환합니다.
- `values`: 주어진 키에 연결된 값들을 반환합니다.

#### 사용한 자료구조 혹은 자료형
- 단어를 정렬해 정렬한 단어를 기준으로 값을 저장하기 위해 (즉 하나의 키에 애너그램인 여러 개의 값이 추가될 수 있기 때문에) 리스트를 값으로 두는 맵을 선언합니다.

***

### 0238 product-of-array-except-self

#### 사용한 자료구조 혹은 자료형
- result 배열의 요소의 구성을 생각 => [1(*nums[3]*nums[2]*nums[1]), 1*nums[0](*nums[3]*nums[2]),1*nums[0]*nums[1](*nums[3]),1*nums[0]*nums[1]*nums[2](*1)]
- 괄호는 오른쪽 곱셈 결과
- 왼쪽 곱셈 결과에 오른쪽 곱셉 결과를 곱함으로써 나눗셈을 쓰지 않고 자신을 제외한 나머지 모든 엘리먼트의 곱셈 결과가 되도록 출력합니다.

### 0121 best-time-to-buy-and-sell-stock

#### 사용한 자료구조 혹은 자료형
- 배열의 요소를 반복문을 통해 순회하면서 저점을 먼저 확인 후 현재 값과 저점의 차이를 확인한다 => O(n) 풀이가 가능해짐.

***

### 0234 palindrome-linked-list
LinkedList<>(): LinkedList 클래스의 생성자입니다. Deque<Integer> 타입의 deque 객체를 생성할 때 사용됩니다. 이 메소드는 새로운 LinkedList 객체를 생성하고 초기화합니다.

add(E e): Deque 인터페이스의 메소드입니다. 여기서는 deque.add(node.val) 형태로 사용되며, deque에 새로운 요소를 추가합니다. node.val은 연결 리스트의 현재 노드에서 값을 가져옵니다.

pollFirst(): Deque 인터페이스의 메소드입니다. deque.pollFirst() 형태로 사용되며, 덱에서 첫 번째 요소를 제거하고 반환합니다. 이 메소드는 덱이 비어 있을 경우 null을 반환합니다.

pollLast(): Deque 인터페이스의 메소드입니다. deque.pollLast() 형태로 사용되며, 덱에서 마지막 요소를 제거하고 반환합니다. 이 메소드도 덱이 비어 있을 경우 null을 반환합니다.

isEmpty(): Deque 인터페이스의 메소드입니다. deque.isEmpty() 형태로 사용되며, 덱이 비어 있는지 여부를 확인합니다. 덱이 비어 있으면 true를, 그렇지 않으면 false를 반환합니다.

size(): Deque 인터페이스의 메소드입니다. deque.size() 형태로 사용되며, 덱에 있는 요소의 수를 반환합니다.

***

### 0021 merge-two-sorted-lists

#### 사용한 자료구조 혹은 자료형
- 연결리스트 요소를 비교하여 작은 값이 있는 쪽을 재귀호출로 엮고 다음 결과를 리턴하는 것이 핵심
- 재귀함수는 항상 기본사례(재귀호출이 종료되는 조건)를 가지고 있어야 함
- 해당 문제에서의 기본사례는 두 리스트 중 하나가 비어있는 경우입니다. 만약 list1이 null이면, 더 이상 병합할 것이 없으므로 list2를 그대로 반환합니다. list2가 null인 경우도 마찬가지입니다.

***

### 0206 reverse-linked-list

#### 사용한 자료구조 혹은 자료형
- 연결리스트의 다음노드와 현재노드를 파라미터로 하여 재귀호출
- 재귀함수 호출 전 현재노드(다음노드로 받은)의 next 포인터를 prev로 지정 후 다음 재귀함수 호출
- 기본사례에서는 재귀함수 파라미터로 null인 다음노드를 전달한 후 마지막 재귀함수에서 prev를 return하게함

***
### 0024 swap-nodes-in-pairs

#### 사용한 자료구조 혹은 자료형
- 기본사례에서 조건을 설정할 때 주의해야함. 즉 재귀함수에서 두 노드의 교환이 이루어지기 때문에 두 노드(head, head.next)에 대한 null 체크가 모두 이뤄줘야 함.

***
### 0328 odd-even-linked-list

#### 사용한 자료구조 혹은 자료형
- 반복문으로 홀짝노드를 처리한다.
- 시간복잡도 O(n): 연결 리스트를 한 번 순회하며 각 노드를 처리하기 때문에, 시간 복잡도는 O(n)입니다. 여기서 n은 입력된 리스트의 노드 수입니다.
  (문제를 해결하는 데 필요한 시간의 양이며 정확히는 n/2번 반복으로 반복문이 수행되는데 실제 반복 횟수가 n/2라 하더라도 Big O 표기법에서는 상수 계수는 무시됨)
- 공간복잡도 O(1): 추가적인 데이터 구조를 사용하지 않고, 고정된 수의 포인터 변수만 사용하기 때문에, 공간 복잡도는 O(1)입니다.
  (입력의 크기에 따라 메모리 사용량이 일정)

***


